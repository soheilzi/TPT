import json
import re
import numpy as np
import csv
from pathlib import Path
import os

# Regular expression to capture the answer after the last "####"
ANS_RE_GSM8k = re.compile(r"####\s*(-?[\d.,]+)")
INVALID_ANS_GSM8k = "[invalid]"

def extract_answer_gsm8k(answer_text):
    """Extracts the final numeric answer from the solution text using regex."""
    match = ANS_RE_GSM8k.search(answer_text)
    if match:
        return match.group(1).strip()
    return INVALID_ANS_GSM8k

def evaluate_gsm8k_solution(model_answer, expected_solution):
    """
    Evaluates if the model's answer matches the expected solution.
    
    Parameters:
    - model_answer: str, the answer generated by the model
    - expected_solution: str, the correct answer

    Returns:
    - bool: True if the answers match, False otherwise
    """
    model_final_answer = extract_answer_gsm8k(model_answer)
    return model_final_answer == expected_solution and model_final_answer != INVALID_ANS_GSM8k

def estimate_pass_at_k(num_samples, num_correct, k):
    """
    Estimates pass@k for each problem and returns an array of pass@k values.
    """
    def estimator(n, c, k):
        if n - c < k:
            return 1.0
        return 1.0 - np.prod(1.0 - k / np.arange(n - c + 1, n + 1))
    
    return np.array([estimator(n, c, k) for n, c in zip(num_samples, num_correct)])

def calculate_pass_at_k_and_write_to_file(results, ks, output_csv, s):
    """
    Calculates pass@k values for the given result dictionary and writes to a CSV file.

    Parameters:
    - results: dict, where each key is a problem ID and each value is the number of correct answers
    - ks: list of int, list of k values for which to calculate pass@k
    - output_csv: str, path to output CSV file
    - s: int, total number of attempts for each problem
    """
    # Convert results to lists of total attempts and correct attempts
    total_attempts = np.full(len(results), s)
    correct_attempts = np.array(list(results.values()))

    # Calculate pass@k for each k value and take mean across problems
    pass_at_k_scores = {f'pass@{k}': estimate_pass_at_k(total_attempts, correct_attempts, k).mean() for k in ks}

    # Write results to CSV file
    with open(output_csv, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Metric", "Score"])
        for k, score in pass_at_k_scores.items():
            writer.writerow([k, score])

    print(f"Pass@k scores written to {output_csv}")

def process_files(file_paths, anspath, ks, output_csv, correct_output_file, s=50):
    """
    Processes multiple JSON files, calculates the number of correct answers per problem,
    and computes pass@k scores. Also saves correct answers to a separate JSON file.

    Parameters:
    - file_paths: list of str, paths to JSON files with question-answer pairs
    - anspath: str, path to JSON file with expected answers
    - ks: list of int, list of k values for pass@k calculation
    - output_csv: str, path to the output CSV file
    - correct_output_file: str, path to the JSON file for correct answers
    - s: int, total number of attempts for each problem
    """
    problem_correct_counts = {}
    correct_answers = []  # List to store correct answer entries

    # Load expected answers from anspath
    with open(anspath, "r") as f:
        expected_answers = {item["idt"]: item["solnum"] for item in json.load(f)}

    # Process each file
    for file_path in file_paths:
        with open(file_path, "r") as f:
            data = json.load(f)
        
        # Evaluate each answer in the file
        for item in data:
            problem_id = item.get("qnum")
            q = item.get("question")
            model_answer = item.get("solution", "")
            expected_solution = expected_answers.get(problem_id, INVALID_ANS_GSM8k)

            if problem_id not in problem_correct_counts:
                problem_correct_counts[problem_id] = 0

            # Increment correct count if answer is correct and add to correct_answers list
            if evaluate_gsm8k_solution(model_answer, expected_solution):
                problem_correct_counts[problem_id] += 1

                if problem_correct_counts[problem_id] <= 1:
                    it = {
                        'id' :  problem_id,
                        'question' : q,
                        'solution' :  model_answer, 
                        'solnum' : expected_solution
                    }
                    correct_answers.append(it)  # Add the correct item to the list

    # Calculate and write pass@k scores to the CSV file
    calculate_pass_at_k_and_write_to_file(problem_correct_counts, ks, output_csv, s)

    # Write correct answers to a JSON file
    with open(correct_output_file, "w") as correct_file:
        json.dump(correct_answers, correct_file, indent=4)
    print(f"Correct answers written to {correct_output_file}")

# Run the processing
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="eval math problems")
    parser.add_argument('--samples_dir', default="samples/math_train/ft", required=True, help="Root directory containing subdirectorys for each model's samswers per problem Each problem folder should include JSON files named e0.json, e1.json, …")
    parser.add_argument('--answer_path', type=str, default="data/gsm8ktrain", help="Path with JSON file of the answers either train or test.")
    parser.add_argument('--num_samples', type=int, default=5, help="Number of samples you want per question  e0.json, e1.json, … to num_samples")
    args = parser.parse_args()

    directories = [d for d in os.listdir(samples_dir) if os.path.isdir(os.path.join(samples_dir, d))]
    # Loop through each directory and set up file paths for processing
    for di in directories:
        # Define the paths based on the current directory
        d = os.path.join(nam, di)
        file_paths = [f"{d}/e{i}.json" for i in range(args.num_samples)]  # List of JSON files
        anspath = args.answer_path  # Path to JSON file with expected answers
        ks = [1, args.num_samples]  # List of k values for pass@k calculation
        output_csv = f"{d}/pass_at_k_results.csv"  # Path to output CSV file
        correct_output_file = f"{d}/correct_answers.json"  # Path to JSON file for correct answers
        s = num_samples  # Total number of attempts per problem

        # Process the files for the current directory
        process_files(file_paths, anspath, ks, output_csv, correct_output_file, s)
